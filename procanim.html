<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Navigation</title>
    <link rel="stylesheet" href="css/blog.css">
</head>
<body>


    <header>
        <h1>Procedural Animation in Unity</h1>
        <p><strong>By Saif Jouda | June. 6 2024</strong></p>
    </header>

    <section>
        <h2>Introduction</h2>
        <img src="images/blog/volumetric/volumetricLighting.jpg" alt="Volumetric Lighting Example">
        <h3>What is it?</h3>
        <p>
            Procedural animation is a technique in computer graphics where animations are created algorithmically rather than being manually crafted by animators. 
         </p>
        <h3>How does it work?</h3> 
        <p>Procedural animation generates movements using algorithms and mathematical functions instead of manual keyframes. It works by:</p>  
        <ul>
            <li>
                <strong>Designing Algorithms:</strong>
                <p>Rules and mathematical models define movements.</p>
            </li>
            <li>
                <strong>Using Parameters:</strong>
                <p>Inputs like environmental factors and user interactions influence animations.</p>
            </li>
            <li>
                <strong>Real-time Calculation:</strong>
                <p> Animations are calculated and rendered dynamically, allowing for adaptive and realistic motions.</p>
            </li>
        </ul>
    </section>

    <section>
        <h2>Animation Rigging in Unity</h2>
        <p>Animation rigging in Unity involves setting up a skeleton (rig) for a character or object, which consists of bones and joints. This rig allows animators to create and control movement. Key components include:</p>
        <ul>
            <li>
                <strong>Skeleton/Bones:</strong>
                <p>Hierarchical structure of bones and joints.</p>
            </li>
            <li>
                <strong>Skinned Mesh Renderer:</strong>
                <p>Component that renders a deformable mesh.</p>
            </li>
            <li>
                <strong>Constraints:</strong>
                <p>Rules that dictate how bones move (e.g., IK constraints for realistic limb movement).</p>
            </li>
        </ul>
        <p>Using Unity's Animation Rigging package, developers can create complex animations by defining these bones, joints, and constraints, facilitating more dynamic and realistic character movements.</p>
    
        <h3>Contraint Components</h3>
        <h4>Blend</h4>
        <p><strong>Function:</strong> Blends the transformations of multiple sources (position, rotation, scale) to a single object.</p>
        <p><strong>Use Case:</strong> Smoothly transitioning an object between different states or animations.</p>

        <img src="images/blog/procedural/blend_constraint.gif">
        
        <h4>Chain IK</h4>
        <p><strong>Function:</strong> Controls a chain of bones to follow a target position, typically for limbs.</p>
        <p><strong>Use Case:</strong> Creating natural limb movements, such as a character’s arm reaching for an object.</p>
        <img src="images/blog/procedural/chainik.gif">
        
        <h4>Damped</h4>
        
        <p><strong>Function:</strong> Applies a damping effect to an object's transformation, smoothing out sudden movements.</p>
        <p><strong>Use Case:</strong> Reducing jitter or oscillations in animations, such as camera shake or soft body dynamics.</p>
        <img src="images/blog/procedural/damped_transform.gif">
        
        <h4>Multi-Aim</h4>
        
        <p><strong>Function:</strong> Orients an object to aim at multiple targets, blending between them based on weights.</p>
        <p><strong>Use Case:</strong> Ensuring an object (like a head or eye) smoothly tracks multiple points of interest.</p>
        <img src="images/blog/procedural/multi_aim.gif">
        
        <h4>Multi-Parent</h4>
        <p><strong>Function:</strong> Allows an object to inherit transformations from multiple parent objects.</p>
        <p><strong>Use Case:</strong> Complex parenting setups where an object needs to follow multiple influences, such as holding an object with both hands.</p>
        
        <img src="images/blog/procedural/multi_parent.gif">
        
        <h4>Multi-Position</h4>
        <p><strong>Function:</strong> Constrains an object’s position to multiple targets, blending their influence.</p>
        <p><strong>Use Case:</strong> Positioning an object relative to several control points, useful in multi-character interactions.</p>
        <img src="images/blog/procedural/multi_position.gif">
        
        <h4>Multi-Referential</h4>
        <p><strong>Function:</strong> Switches an object’s reference between different targets seamlessly.</p>
        <p><strong>Use Case:</strong> Changing the parent or reference of an object dynamically, such as switching which hand holds an object.</p>

        <img src="images/blog/procedural/multi_ref.gif">
        
        <h4>Multi-Rotation</h4>
        <p><strong>Function:</strong> Blends the rotational influence of multiple targets on an object.</p>
        <p><strong>Use Case:</strong> Smoothing out rotational transitions between different animations or control points.</p>

        <img src="images/blog/procedural/multi_rotation.gif">
        
        <h4>Override</h4>
        <p><strong>Function:</strong> Overrides the transformation of an object with specified values or influences.</p>
        <p><strong>Use Case:</strong> Temporarily changing an object’s transformation for specific actions or states.</p>

        <img src="images/blog/procedural/override_transform.gif">
        
        <h4>Twist Chain</h4>
        <p><strong>Function:</strong> Distributes a twist along a chain of bones evenly.</p>
        <p><strong>Use Case:</strong> Creating natural twisting motions in body parts like the forearm or spine.</p>

        <img src="images/blog/procedural/twistchain.gif">
        
        <h4>Twist Correction</h4>
        <p><strong>Function:</strong> Corrects unwanted twisting in a bone, ensuring proper deformation.</p>
        <p><strong>Use Case:</strong> Maintaining the correct shape of a mesh during complex rotations, such as twisting an arm.</p>

        <img src="images/blog/procedural/twist_correction.gif">
        
        <h4>Two Bone IK</h4>
        <p><strong>Function:</strong> Controls two connected bones (like upper and lower arm) to reach a target position.</p>
        <p><strong>Use Case:</strong> Animating joints such as elbows and knees with natural bending and reaching motions.</p>
        <img src="images/blog/procedural/two_bone_ik.gif">

    </section>

    <section>
        <h2>Blender Setup</h2>

        <h3>Create a shape</h3>
        <p>Create the desired shape you want to animate.</p>
        <img src="images/blog/procedural/createShape.png">

        <h3>Add Armature</h3>
        <p>Press shift+a then click on Armature to add the base bone.</p>
        <img src="images/blog/procedural/addBone.png">

        <h4>Change Viewport display (recommended)</h4>
        <p>To see the bone structure easier, go to Data>Viewport Display, then check the In Front box.</p>
        <img src="images/blog/procedural/inFront.png">

        <h3>Build the armature</h3>
        <p>With the base bone selected in object mode, go into edit mode then you can:</p>
        <p>Press E to create a new bone at the selected bone</p>
        <p>Press G to move and rotate the selected mode</p>
        <img src="images/blog/procedural/editBone.png">

        <h3>Connect the Object with the Armature</h3>
        <p>Shift click the armature THEN the object, then press CNTRL/CMMD+P, finally select "With Automatic Weights"</p>
        <img src="images/blog/procedural/attachBone.png">

        <h3>Weight Paint (Optional)</h3>
        <p>To improve how the bones bend the objects, you customize how each bone affects the mesh. To do this select the mesh/object in object mode then switch to Weight Paint. Here you can  </p>
        get wieght from https://docs.blender.org/manual/en/latest/sculpt_paint/weight_paint/introduction.html 
        <img src="images/blog/procedural/wieghtPaint.png">
        <img src="images/blog/procedural/Paint.png">

        <h3>Export</h3>
        <p>Export the project as a .fbx file and place it in your Unity assets folder.</p>
        <img src="images/blog/procedural/export.png">

    </section>
    
    <section>
        <h2>Unity Setup</h2>
        <h3>Get the Package</h3>
        <p>Get the "Animation Rigging" package from the Unity Registry</p>
        <img src="images/blog/procedural/animationRig.png">


        <h3>Setup the Object</h3>
        <p>The .fbx file you imported should be in a prefab state. Drag and drop it into your scene. While the "Armature" child object is selected, click on "Animation Rigging">"Rig Setup". This will add some important components to the object. In addition, if you would like to see the bones, do "Animation Rigging">"Bone Renderer Setup".</p>
        <img src="images/blog/procedural/addObject.png">

        <h3>Animation Rigging Component</h3>
        <p>In Armature, a Rig child object should have been created. Create a child object for "Rig" for the constraint. Add the desired constrain component on the new object we just created. From here, each different constrain have their own requirements. For this example, we will use the Two Bone IK Constraint.</p>
        
        
        <img src="images/blog/procedural/component.png">
        
        <img src="images/blog/procedural/rigObjects.png">

        <img src="images/blog/procedural/visual.png">
        
        <img src="images/blog/procedural/play.png">


    </section>
    <section>
        <h2>Results</h2>

        gif of monsters

        add link to voluetric lighting
    </section>


    <button class="back-to-top" onclick="scrollToTop()">Back to Top</button>

    <script>
        // Function to scroll to the top of the page
        function scrollToTop() {
            document.body.scrollTop = 0;
            document.documentElement.scrollTop = 0;
        }

        // Show or hide the "Back to Top" button based on scroll position
        window.onscroll = function () {
            showBackToTopButton();
        };

        function showBackToTopButton() {
            var button = document.querySelector('.back-to-top');
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                button.style.display = 'block';
            } else {
                button.style.display = 'none';
            }
        }
    </script>
    

</body>
</html>
